//============================================================================
// Name        : HW2.cpp
// Author      : Alex Galvan and Suryansh Goyal
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================
#include <iostream>
#include <time.h>
#include <string.h>
#include <vector>
#include <cmath>

using namespace std;



vector<vector<int>> powerSet; // vector of combinations

unsigned int Lucas(int n);
int sum33(int n);
int comboSum(int maxSum);

/*1.
 * Given: R(n) = 4R(n−1)−3R(n−2), R(0) = 2 and R(1) = 8
 * We obtain the following values:
 * R(0)=2
 * R(1)=8
 * R(2)=26
 * R(3)=80
 * R(4)=242
 * .......
 *
 * The "nth" term in this sequence can be written as:
 * R(n)=(3^n)-1    -- where "^" is the exponent function (not to be confused with XOR)
 *
 * The order of growth is O(3^n)
 *
 */

int main() {
	string input;
	cout
			<< "Would you to do Lucas Number (LN) or Suribach's Magic Square (SMS)?:";
	cin >> input;
	if (input == "LN") {
		double start, end;
		double currTimeElapsed;
		double prevTimeElapsed;

		int input = 0;
		cout << "How many Lucas Numbers do you want to print?:";
		cin >> input;
		for (int i = 0; i <= input; i++) {
			start = clock();
			cout << "L(" << i << "): " << Lucas(i);
			end = clock();
			currTimeElapsed = (end - start) / CLOCKS_PER_SEC;
			cout << ", time: " << currTimeElapsed << " seconds";

			if (i > 0) {
				if (prevTimeElapsed != 0) {
					cout << ", Ratio of successive calculations:"
							<< currTimeElapsed / prevTimeElapsed;
				}
			}
			cout << "\n";

			prevTimeElapsed = currTimeElapsed;

		}
		cout<< "The order of growth for Lucas Numbers is O(2^n)."
				" Édouard Lucas is also known for his study of the Fibonacci Sequence.\n";
	} else if (input == "SMS") {
		int MagicSquare[16] = { 1, 14, 14, 4, 11, 7, 6, 9, 8, 10, 10, 5, 13, 2,
				3, 15 };
		cout << "The Suribach's magic square is: \n";
		for (int i = 0; i < 16; i++) { // prints the magic square
			cout << MagicSquare[i] << " ";
			if ((i + 1) % 4 == 0) {
				cout << "\n";
			}
		}

		int N = pow(2, 16);
		for (int i = 0; i < N; i++) {
			vector<int> subSet;
			for (int j = 0; j < 16; j++) {
				if (i & (1 << j)) {
					subSet.push_back(MagicSquare[j]);
				}
			}
			powerSet.push_back(subSet);
		}

		for (int i = 1; i <= 16; i++) {
			cout << "The combinations of " << i
					<< " from Magic Square that add up to 33 is " << sum33(i)
					<< "\n";
		}

		for (int i = 0; i <= 132; i++) {
			cout << "The combinations from Magic Square that add up to " << i
					<< " is " << comboSum(i) << "\n";
		}

		cout<<"The sum that can be created with the greatest number of combinations is 66 "
				"and the number of combinations is 1364.\n"
				"Interesting Fact: Starting with the sum of 0, "
				"the combinations increase from 1 to 1364\n"
				"and then follow the same pattern until the sum is 66 and "
				"then decrease in the same pattern until the sum is 132 which is\n"
				"the greatest sum that can be generated by summing all "
				"the cell values in the Magic Square.\n";
	} else {
		cout << "Invalid Input!\n";
		exit(0);
	}
}

/*
 * Generates the 'nth' Lucas Number through recursion
 */
unsigned int Lucas(int n) {
	unsigned int result=0;
	if (n == 0) {
		result=2;
		return result;
	} else if (n == 1) {
		result=1;
		return result;
	} else {
		return (Lucas(n - 1) + Lucas(n - 2));
	}
}

/*
 * Finds all combinations of "n" that add up to 33 from the Suribach's Magic Square
 */
int sum33(int n) {
	int count = 0;
	int sum = 0;
	int subSize;
	int size = powerSet.size();
	for (int i = 0; i < size; i++) {
		subSize = powerSet[i].size();
		if (subSize == n) {
			sum = 0;
			for (int j = 0; j < subSize; j++) {
				sum += powerSet[i][j];
			}
			if (sum == 33) {
				count++;
			}
		}
	}

	return count;
}

/*
 * Returns all possible combinations from the Suribach's Magic Square that add
 * up to "maxSum"
 */
int comboSum(int maxSum) {
	int count = 0;
	int sum = 0;
	int subSize;
	int size = powerSet.size();
	for (int i = 0; i < size; i++) {
		subSize = powerSet[i].size();
		sum = 0;
		for (int j = 0; j < subSize; j++) {
			sum += powerSet[i][j];
		}
		if (sum == maxSum) {
			count++;
		}
	}

	return count;
}

//---------BONUS QUESTION-----------

